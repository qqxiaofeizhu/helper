### 哈希表

#### 原理

1. 基于数组实现
- 数组进行插入效率比较低
- 数组基于下标查找比较高，基于数据查找效率比较低
- 数组进行删除，修改操作效率比较低

#### 优势
1. 可以提供快速的插入删除查找操作
2. 无论数据量多大，插入和删除值接近常量的时间
3. 哈希表的速度比树还要快，基本可以瞬间可以查找到需要的元素
4. 哈希表相对树来说编码要容易

#### 缺点
1. 哈希中的数据是无序的
2. 哈希表中key值是不允许重复的，不可以置放相同的key值，保存不同的元素

### 案例

1. 公司使用数据结构保存所有的员工

2. 联系人和电话号码

3. 50000个单词存储

### 字母转数字

单词字母转下标值，就是字l母/文字转数字

目前计算机内编码格式
- ascii 英文
- iso-8869-1 欧洲
- gb-xxx 国标
- unicode 包含以上所有的编码（utf-8 utf-16 utf-32）

方案一：

[X]数字相加： 把一个一个单词转为数字再统一相加；很多的单词的下标都是一样的

方案二：

[X]幂的连乘：7654 = 7*10^3 + 6*10^2 + 5*10^1 + 4 * 10^0 ; 造成大量的空间浪费

方案三：

- 哈希化：将大数字转化为数组范围内下标的过程，我们称之为哈希化
- 哈希函数： 将单词转换为大数字，大数字转为数组范围内的下标的代码实现
- 哈希表： 整个存储的数据结构，称之为哈希表

冲突：

当哈希化之后得到的下标值发生了重复的现象称之为冲突，冲突不可避免，我们只能解决冲突

冲突的解决方案：
- 链地址法
- 开放地址法

1. 链地址法（拉链法）

数组每一个位置存放不再是一个单独的数据而是一个链表或者数组

数据插入前端的话使用链表（新数据使用概率比较高）

数据插入后端的话数组和链表性能一致

2. 开放地址法

开放地址法就是寻找空白的位置来放置冲突的数据项，开放地址法有三种寻找方法

- 线性探测
- 二次探测
- 再哈希法

线性探测：线性查找合适的位置进行放置数据，读取数据在遇到空的位置停止查找， 删除数据的时候不可以把当前数据的数据项设置成null,设置成-1

连续的填充单元称为聚集，聚集的哈希表会影响性能，无论是插入/查询/删除都会影响，会探寻多次

二次探测：二次探测主要优化的是线性探测的步长

对于指定的关键字，步长是一样的，会引起聚集

再哈希法：和第一个哈希函数的结果不同;不能输出为0;

stepSize = constant - (key % constant) (constant 质数，小于数组的容量)

### 哈希化的效率

- 哈希表中在执行插入和删除的效率比较高，特别是在没有产生冲突的时候
- 发生冲突，存取时间取决于探测的长度有关
- 平均探测长度以及平均存取时间，取决于填装因子，填装因子越大，探测长度越大
- 随着填充因子的变大，效率低下的情况下，在不同开地址法的链地址法中更为严重

1. 装填因子

- 装填因子是表示哈希表中包含的数据项和整个哈希表长度的比值
- 装填因子=总数据项/哈希表长度
- 开放地址最大的装填因子是1
- 链地址法的装填因子可能大于1

一般开发都是使用链地址法去解决可能出现的冲突，冲突随着装填因子的增大呈线性增长，开地址法呈指数增长


### 优秀的哈希函数

1. 尽可能减少乘法和除法(霍纳法则（秦九韶算法）[提取法])
2. 下标值尽量均匀分布(在使用常量过程中，尽量使用质数，开地址法)

质数（除自己和1外不能被其他数整除，但不包含1）的使用：

哈希表的长度;N次幂的底数

javaHashMap使用的位运算不是取模运算




















